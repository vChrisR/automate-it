---
title: 'The right tool for the job'
date: Thu, 16 Mar 2017 12:00:02 +0000
draft: false
tags: ['Cloud Foundry', 'Pivotal', 'Right tool for the job', 'Tools', 'vRA', 'vRealize Automation', 'vRealize Orchestrator', 'vRO']
---

I work with vRealize Automation and vRealize Orchestrator on a daily basis. And I really enjoy doing so, especially the custom code development part. vRO gives a lot of flexibility and it's not often that I'm unable to build what my customers need. Whetever the request I usually find a way to emply vRA and vRO in such a way that if fulfills the customers need. But more and more often do I wonder if we're using the right tool for the job. ![](http://icons.iconarchive.com/icons/icons8/ios7/256/Household-Hammer-icon.png) Today I presented a break-out session during the annual [NLVMUG](http://nlvmug.com) UserCon. In the presentation we emphasized the importance of using the right tool for the job. After all, you don't drive a nail in the wall with a power drill. you can do so if you really want to but you'll probably spent more time than needed putting up your new painting and likely destroy you power drill in the process. It's similar in enterprise IT: You can use a customizable tool like vRA/vRO for nearly anything. But that doesn't mean you should. But if you can make it work anyway then why not? First of all: If you're using a product to do something that it wasn't originally intended to do you'll spent a lot of time and money to make it do what you actually want.  But getting the product to do that is only the beginning. Now you need to maintain the product customizations. chances are something will break at the next product upgrade. So you postpone the upgrade, then postpone again and in the end the upgrade never happens because the risk is just too high. Let me give an example: Let's say you're trying to deploy in-house developed code through different life cycle stages. You could argue that everything needs to run on a virtual machine so you start out by automating virtual machine deployment. You'll probably use vRA or something similar to do that for you. After this first step you realize that the code does not run on an bare OS, you may need IIS or .NET or Java or a bunch of shared libraries. So you decide to automate the deployment of middleware software as well. But that still isn't enough to run the code. You also need a database, a load balancer, an SSL certificate and last but not least: you need a way to deploy the code to your machines and configure the way it's running.  Oh and of course all this needs to be triggered by the code repository and be completely self service. By the time you have implemented all this you'll have written tons of custom installation scripts and integration workflows. Automating code deployment can be tricky to say the least. And in my opinion all this difficulty stems from the fact that we're starting with the VM as the unit of deployment. The actual unit of deployment is the code/application your developers are writing. By using the wrong data as input for the tool selection you ended up with the wrong tool. Luckily there are tools designed for application deployment. One of them is called [Cloud Foundry](https://www.cloudfoundry.org/). If you use the [Pivotal](https://pivotal.io/) distribution you can set it up in a day or so. And then your developers can just run cf push and their code is running. In the cloud. Sounds a lot better than writing countless installation scripts and custom integrations doesn't it? Also, the Cloud Foundry platform gives you loads of options you wouldn't have out of the box with tools like vRA: auto-scaling, easy manual scaling, application health monitoring, service bindings, application statistics, centralized logging, custom logging endpoints and lots more. There is one major "drawback" however: your applications need to be cloud native or [12factor](https://12factor.net/) apps. But you'll have to transform your apps into cloud native apps at some point in the future anyways so why not start now?